# 接口概述
API名称：字典查询

API描述：

请求方式：GET

接口地址：{protocol}://{host:port}/api/v1/dataapi/execute/dict/query

# Header参数列表
| 参数名称 | 参数类型 | 参数说明 | 示例 | 是否必须 |
| -------------| -------------| -------------| -------------| -------------|
| AppKey| String| 应用标识AppKey| appKey1| true|
| Signature| String| 请求签名| 12ft6UT890| true|
| Timestamp| String| 请求时时间字符串| 2023-01-19 14:08:30| true|
# 请求Query参数列表
| 参数名称 | 参数类型 | 参数说明 | 示例值 | 是否必填 |
| -------------| -------------| -------------| -------------| -------------|
| pageNum| bigint| | 1| true|
| pageSize| bigint| | 10| true|
| dictType| string| | liming| true|
# 响应参数列表
| 参数名称 | 参数类型 | 参数说明 | 示例 | 是否必须 |
| -------------| -------------| -------------| -------------| -------------|
| success| Boolean| 是否成功标识| true| true|
| errCode| String| 错误异常代码| -1| true|
| errMessage| String| 错误异常消息| 请求时间参数需要在5分钟以内，Timestamp...| true|
| data| Object| 返回对象，该字段仅success为true时返回|  | true|
## Data字段详细信息
无
# 调用示例信息
## 异常代码信息
无
## 请求示例
```SHELL
curl 'http://172.20.4.32:18022/api/v1/dataapi/test/dict/query' \
  -H 'Content-Type: application/json' \
  --data-raw '{"pageSize":"10","pageNum":"1","dictType":"job_type"}'

```
## 正常返回示例
```JSON
{
	"total":5,
	"data":[
		{
			"code":"4",
			"value":"jar"
		},
		{
			"code":"1",
			"value":"java类"
		},
		{
			"code":"2",
			"value":"spring bean"
		},
		{
			"code":"9",
			"value":"其他"
		},
		{
			"code":"3",
			"value":"Rest 调用"
		}
	],
	"totalPage":1,
	"currentPageNum":1,
	"pageSize":10
}

```
## 异常返回示例
```JSON
{
	"errCode":"",
	"success":false,
	"errMessage":"could not found value : dictType"
}

```
# 请求签名算法
## 对于每一次HTTP或HTTPS协议请求，我们会根据访问中的签名信息验证访问请求者身份。
具体由使用AppKey和AppSecret对称加密验证实现。其中AppKey是访问者身份，AppSecret是加密签名字符串和服务器端验证签名字符串的密钥，必须严格保密谨防泄露。
## 步骤一：指定请求参数
在代码中指定请求参数，参数中需要包含公共请求头和接口必备的参数信息
说明: 请求参数中不允许出现以Signature为key的参数

示例代码如下：
```Java
    private static final String DATE_FORMAT_STRING ="yyyy-MM-dd HH:mm:ss";
    private static final String TIME_ZONE ="Asia/Shanghai";

    SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT_STRING);
    df.setTimeZone(TimeZone.getTimeZone(TIME_ZONE));
    String timestamp = df.format(new Date());

    String appKey = "testAppId", appSecret = "Uy56984FgTb",  url ="/api/v1/dataapi/execute/abc", method ="POST";
    Map<String, Object> parasMap = new HashMap<>();
    parasMap.put("key2","b");
    parasMap.put("key1","a");
```
## 步骤二：构造生成签名的请求字符串

首先介绍下面会用到的特殊URL编码，这个是POP特殊的一种规则，即在一般的URLEncode后再增加三种字符替换：加号（+）替换成 %20、星号（*）替换成 %2A、%7E 替换回波浪号（~）
参考代码如下：
```Java
/**
     * POP特殊的URL编码规则
     * 在一般的URLEncode后再增加三种字符替换：加号（+）替换成 %20、星号（*）替换成 %2A、%7E 替换回波浪号（~）
     */
    private static String specialUrlEncode(String value) throws UnsupportedEncodingException {
        return java.net.URLEncoder.encode(value, CHARSET).replace("+", "%20").replace("*", "%2A").replace("%7E", "~");
    }
```
## 
构造待签名的请求字符串
示例代码如下
```Java
    private static String buildSignString(String url, String method, String appKey,String timestamp, Map<String, Object> parasMap) throws UnsupportedEncodingException {
        // 加入appKey
        parasMap.put("appKey",appKey);
        // 加入timestamp时间参数
        parasMap.put("timestamp",timestamp);

        // 根据参数Key排序
        TreeMap<String, Object> sortParasMap = new TreeMap<>(parasMap);

        //把排序后的参数顺序拼接成如下格式：* specialUrlEncode(参数Key) + "=" + specialUrlEncode(参数值)
        java.util.Iterator<String> it = sortParasMap.keySet().iterator();
        StringBuilder sortQueryStringTmp = new StringBuilder();
        while (it.hasNext()) {
            String key = it.next();
            sortQueryStringTmp.append("&").append(specialUrlEncode(key)).append("=").append(specialUrlEncode(sortParasMap.get(key).toString()));
        }
        String sortedQueryString = sortQueryStringTmp.substring(1);// 去除第一个多余的&符号

        //按POP的签名规则拼接成最终的待签名串。规则如下：* HTTPMethod + “&” + specialUrlEncode(url) + ”&” + specialUrlEncode(sortedQueryString)
        return method.toUpperCase() + "&" + specialUrlEncode(url) + "&" + specialUrlEncode(sortedQueryString);
    }
```
## 步骤三：签名
签名采用HmacSHA1算法 + Base64，编码采用UTF-8。参考代码如下：
```Java

    /**
     * appSecret：您的AppKey对应的密钥AppSecret，特别说明：POP要求需要后面多加一个“&”字符，即appSecret + “&”
     * stringToSign：即第二步生成的待签名请求串
     */
    private static String sign(String appSecret, String stringToSign) throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException {
        SecretKeySpec signingKey = new SecretKeySpec(appSecret.getBytes(CHARSET), ALGORITHM_HMAC_SHA1);
        Mac mac = Mac.getInstance(ALGORITHM_HMAC_SHA1);
        mac.init(signingKey);
        byte[] signData = mac.doFinal(stringToSign.getBytes(CHARSET));
        return Base64.getEncoder().encodeToString(signData);
    }
```
# 完整的Java签名Demo代码：
```Java
public class SignUtilTest {
    private static final String DATE_FORMAT_STRING ="yyyy-MM-dd HH:mm:ss";
    private static final String TIME_ZONE ="Asia/Shanghai";


    public static void main(String[] args) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException {
        SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT_STRING);
        df.setTimeZone(TimeZone.getTimeZone(TIME_ZONE));
        String timestamp = df.format(new Date());

        String appKey = "testAppId", appSecret = "Uy56984FgTb",  url ="/api/v1/dataapi/execute/abc", method ="POST";
        Map<String, Object> parasMap = new HashMap<>();
        parasMap.put("key2","b");
        parasMap.put("key1","a");

        String stringToSign = buildSignString(url,method,appKey,timestamp,parasMap);

        String signature = sign(appSecret, stringToSign);

        System.out.println("Signature: " + signature);
    }


    /**
     * 构造生成签名的请求字符串
     */
    private static String buildSignString(String url, String method, String appKey,String timestamp, Map<String, Object> parasMap) throws UnsupportedEncodingException {
        // 加入appKey
        parasMap.put("appKey",appKey);
        // 加入timestamp时间参数
        parasMap.put("timestamp",timestamp);

        // 根据参数Key排序
        TreeMap<String, Object> sortParasMap = new TreeMap<>(parasMap);

        //把排序后的参数顺序拼接成如下格式：* specialUrlEncode(参数Key) + "=" + specialUrlEncode(参数值)
        java.util.Iterator<String> it = sortParasMap.keySet().iterator();
        StringBuilder sortQueryStringTmp = new StringBuilder();
        while (it.hasNext()) {
            String key = it.next();
            sortQueryStringTmp.append("&").append(specialUrlEncode(key)).append("=").append(specialUrlEncode(sortParasMap.get(key).toString()));
        }
        String sortedQueryString = sortQueryStringTmp.substring(1);// 去除第一个多余的&符号

        //按POP的签名规则拼接成最终的待签名串。规则如下：* HTTPMethod + “&” + specialUrlEncode(url) + ”&” + specialUrlEncode(sortedQueryString)
        return method.toUpperCase() + "&" + specialUrlEncode(url) + "&" + specialUrlEncode(sortedQueryString);
    }

    /**
     * 签名和验签公用方法
     * 签名采用HmacSHA1算法 + Base64，编码采用UTF-8
     */
    private static String sign(String appSecret, String stringToSign) throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException {
        SecretKeySpec signingKey = new SecretKeySpec(appSecret.getBytes(CHARSET), ALGORITHM_HMAC_SHA1);
        Mac mac = Mac.getInstance(ALGORITHM_HMAC_SHA1);
        mac.init(signingKey);
        byte[] signData = mac.doFinal(stringToSign.getBytes(CHARSET));
        return Base64.getEncoder().encodeToString(signData);
    }

    /**
     * POP特殊的URL编码规则
     * 在一般的URLEncode后再增加三种字符替换：加号（+）替换成 %20、星号（*）替换成 %2A、%7E 替换回波浪号（~）
     */
    private static String specialUrlEncode(String value) throws UnsupportedEncodingException {
        return java.net.URLEncoder.encode(value, CHARSET).replace("+", "%20").replace("*", "%2A").replace("%7E", "~");
    }
}
```
